import hashlib

def G(seed, counter, output_length):
    """
    Function G: Generates pseudorandom bytes using SHAKE256 from a given seed and counter.
    
    Args:
    - seed (bytes): Public seed.
    - counter (int): Counter for distinct calls.
    - output_length (int): Number of bytes to output.
    
    Returns:
    - bytes: Pseudorandomly generated bytes of specified output length.
    """
    # Concatenate seed with counter byte and hash using SHAKE256 for extensible output
    shake = hashlib.shake_256()
    shake.update(seed + counter.to_bytes(1, 'big'))
    return shake.digest(output_length)

def generate_C_L_Q1(public_seed, m, n, v):
    """
    Generates the matrices C, L, Q1 as described in the provided specifications.
    
    Args:
    - public_seed (bytes): Seed for random generation.
    - m (int): Number of rows.
    - n (int): Number of columns in L.
    - v (int): Parameter v defining dimensions of Q1.
    
    Returns:
    - tuple: (C, L, Q1), where C is m x 1, L is m x n, and Q1 is m x (v*(v+1)/2 + v*m).
    """
    # Calculate the output length needed for each 16-row block
    output_len = 2 * (1 + n + ((v * (v + 1)) // 2) + v * m)
    
    # Initialize matrices C, L, Q1
    C = []
    L = [[] for _ in range(n)]
    Q1 = [[] for _ in range(v * (v + 1) // 2 + v * m)]
    
    # Process each block of 16 rows
    for block in range((m + 15) // 16):  # Number of 16-row blocks
        # Get output from G
        output = G(public_seed, block, output_len)
        
        # Parse output into sections for C, L, and Q1
        index = 0
        for row in range(16):
            if block * 16 + row >= m:
                break  # If m is not divisible by 16, stop once we reach the end of rows
            
            # C: Append 2 bytes (16 bits)
            C.append(int.from_bytes(output[index:index + 2], 'big') & ((1 << 16) - 1))
            index += 2
            
            # L: Append 2n bytes (each column 2 bytes per row)
            for col in range(n):
                L[col].append(int.from_bytes(output[index:index + 2], 'big') & ((1 << 16) - 1))
                index += 2
            
            # Q1: Append the remaining bytes for Q1
            for col in range(v * (v + 1) // 2 + v * m):
                Q1[col].append(int.from_bytes(output[index:index + 2], 'big') & ((1 << 16) - 1))
                index += 2

    return C, L, Q1


